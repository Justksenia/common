// Code generated by ogen, DO NOT EDIT.

package gen

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *ChannelAttributes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChannelAttributes) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("channel_id")
		e.Str(s.ChannelID)
	}
	{
		e.FieldStart("verified")
		e.Bool(s.Verified)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		e.FieldStart("verification_date")
		e.Str(s.VerificationDate)
	}
}

var jsonFieldsNameOfChannelAttributes = [5]string{
	0: "channel_id",
	1: "verified",
	2: "name",
	3: "title",
	4: "verification_date",
}

// Decode decodes ChannelAttributes from json.
func (s *ChannelAttributes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChannelAttributes to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "channel_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ChannelID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel_id\"")
			}
		case "verified":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Verified = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "verification_date":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.VerificationDate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChannelAttributes")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChannelAttributes) {
					name = jsonFieldsNameOfChannelAttributes[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChannelAttributes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChannelAttributes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClientByFilterResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClientByFilterResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfClientByFilterResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes ClientByFilterResponse from json.
func (s *ClientByFilterResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClientByFilterResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]ClientData, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ClientData
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClientByFilterResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClientByFilterResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClientByFilterResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClientByFilterResponseMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClientByFilterResponseMeta) encodeFields(e *jx.Encoder) {
	{
		if s.Pagination.Set {
			e.FieldStart("pagination")
			s.Pagination.Encode(e)
		}
	}
}

var jsonFieldsNameOfClientByFilterResponseMeta = [1]string{
	0: "pagination",
}

// Decode decodes ClientByFilterResponseMeta from json.
func (s *ClientByFilterResponseMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClientByFilterResponseMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pagination":
			if err := func() error {
				s.Pagination.Reset()
				if err := s.Pagination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pagination\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClientByFilterResponseMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClientByFilterResponseMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClientByFilterResponseMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClientCrmID as json.
func (s ClientCrmID) Encode(e *jx.Encoder) {
	unwrapped := int(s)

	e.Int(unwrapped)
}

// Decode decodes ClientCrmID from json.
func (s *ClientCrmID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClientCrmID to nil")
	}
	var unwrapped int
	if err := func() error {
		v, err := d.Int()
		unwrapped = int(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ClientCrmID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ClientCrmID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClientCrmID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClientData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClientData) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Attributes.Set {
			e.FieldStart("attributes")
			s.Attributes.Encode(e)
		}
	}
}

var jsonFieldsNameOfClientData = [2]string{
	0: "id",
	1: "attributes",
}

// Decode decodes ClientData from json.
func (s *ClientData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClientData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			if err := func() error {
				s.Attributes.Reset()
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClientData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClientData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClientData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClientDataAttributes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClientDataAttributes) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("clientID")
		s.ClientID.Encode(e)
	}
	{
		e.FieldStart("clientUsername")
		e.Str(s.ClientUsername)
	}
	{
		e.FieldStart("activeBalance")
		e.Float64(s.ActiveBalance)
	}
	{
		e.FieldStart("blockedBalance")
		e.Float64(s.BlockedBalance)
	}
	{
		e.FieldStart("profitBalance")
		e.Float64(s.ProfitBalance)
	}
	{
		e.FieldStart("withdrawlBalance")
		e.Float64(s.WithdrawlBalance)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PublishedAt.Set {
			e.FieldStart("publishedAt")
			s.PublishedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.OrganisationID.Set {
			e.FieldStart("organisationID")
			s.OrganisationID.Encode(e)
		}
	}
}

var jsonFieldsNameOfClientDataAttributes = [10]string{
	0: "clientID",
	1: "clientUsername",
	2: "activeBalance",
	3: "blockedBalance",
	4: "profitBalance",
	5: "withdrawlBalance",
	6: "createdAt",
	7: "updatedAt",
	8: "publishedAt",
	9: "organisationID",
}

// Decode decodes ClientDataAttributes from json.
func (s *ClientDataAttributes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClientDataAttributes to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientID\"")
			}
		case "clientUsername":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ClientUsername = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientUsername\"")
			}
		case "activeBalance":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.ActiveBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeBalance\"")
			}
		case "blockedBalance":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.BlockedBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockedBalance\"")
			}
		case "profitBalance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.ProfitBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profitBalance\"")
			}
		case "withdrawlBalance":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.WithdrawlBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withdrawlBalance\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "publishedAt":
			if err := func() error {
				s.PublishedAt.Reset()
				if err := s.PublishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publishedAt\"")
			}
		case "organisationID":
			if err := func() error {
				s.OrganisationID.Reset()
				if err := s.OrganisationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organisationID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClientDataAttributes")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClientDataAttributes) {
					name = jsonFieldsNameOfClientDataAttributes[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClientDataAttributes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClientDataAttributes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClientResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClientResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
	{
		if s.Meta != nil {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfClientResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes ClientResponse from json.
func (s *ClientResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClientResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			if err := func() error {
				s.Meta = nil
				var elem ClientResponseMeta
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Meta = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClientResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClientResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClientResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClientResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClientResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Attributes.Set {
			e.FieldStart("attributes")
			s.Attributes.Encode(e)
		}
	}
}

var jsonFieldsNameOfClientResponseData = [2]string{
	0: "id",
	1: "attributes",
}

// Decode decodes ClientResponseData from json.
func (s *ClientResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClientResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			if err := func() error {
				s.Attributes.Reset()
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClientResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClientResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClientResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClientResponseDataAttributes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClientResponseDataAttributes) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("clientID")
		s.ClientID.Encode(e)
	}
	{
		e.FieldStart("clientUsername")
		e.Str(s.ClientUsername)
	}
	{
		e.FieldStart("activeBalance")
		e.Float64(s.ActiveBalance)
	}
	{
		e.FieldStart("blockedBalance")
		e.Float64(s.BlockedBalance)
	}
	{
		e.FieldStart("profitBalance")
		e.Float64(s.ProfitBalance)
	}
	{
		e.FieldStart("withdrawlBalance")
		e.Float64(s.WithdrawlBalance)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PublishedAt.Set {
			e.FieldStart("publishedAt")
			s.PublishedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.OrganisationID.Set {
			e.FieldStart("organisationID")
			s.OrganisationID.Encode(e)
		}
	}
}

var jsonFieldsNameOfClientResponseDataAttributes = [10]string{
	0: "clientID",
	1: "clientUsername",
	2: "activeBalance",
	3: "blockedBalance",
	4: "profitBalance",
	5: "withdrawlBalance",
	6: "createdAt",
	7: "updatedAt",
	8: "publishedAt",
	9: "organisationID",
}

// Decode decodes ClientResponseDataAttributes from json.
func (s *ClientResponseDataAttributes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClientResponseDataAttributes to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientID\"")
			}
		case "clientUsername":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ClientUsername = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientUsername\"")
			}
		case "activeBalance":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.ActiveBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeBalance\"")
			}
		case "blockedBalance":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.BlockedBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockedBalance\"")
			}
		case "profitBalance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.ProfitBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profitBalance\"")
			}
		case "withdrawlBalance":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.WithdrawlBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withdrawlBalance\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "publishedAt":
			if err := func() error {
				s.PublishedAt.Reset()
				if err := s.PublishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publishedAt\"")
			}
		case "organisationID":
			if err := func() error {
				s.OrganisationID.Reset()
				if err := s.OrganisationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organisationID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClientResponseDataAttributes")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClientResponseDataAttributes) {
					name = jsonFieldsNameOfClientResponseDataAttributes[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClientResponseDataAttributes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClientResponseDataAttributes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClientResponseMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClientResponseMeta) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfClientResponseMeta = [0]string{}

// Decode decodes ClientResponseMeta from json.
func (s *ClientResponseMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClientResponseMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return errors.Errorf("unexpected field %q", k)
		}
	}); err != nil {
		return errors.Wrap(err, "decode ClientResponseMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClientResponseMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClientResponseMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CommissionID as json.
func (s CommissionID) Encode(e *jx.Encoder) {
	unwrapped := int(s)

	e.Int(unwrapped)
}

// Decode decodes CommissionID from json.
func (s *CommissionID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommissionID to nil")
	}
	var unwrapped int
	if err := func() error {
		v, err := d.Int()
		unwrapped = int(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CommissionID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CommissionID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommissionID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateChannelReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateChannelReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCreateChannelReq = [1]string{
	0: "data",
}

// Decode decodes CreateChannelReq from json.
func (s *CreateChannelReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChannelReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateChannelReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateChannelReq) {
					name = jsonFieldsNameOfCreateChannelReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateChannelReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChannelReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateChannelReqData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateChannelReqData) encodeFields(e *jx.Encoder) {
	{
		if s.ChannelID.Set {
			e.FieldStart("channel_id")
			s.ChannelID.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateChannelReqData = [2]string{
	0: "channel_id",
	1: "title",
}

// Decode decodes CreateChannelReqData from json.
func (s *CreateChannelReqData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChannelReqData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "channel_id":
			if err := func() error {
				s.ChannelID.Reset()
				if err := s.ChannelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel_id\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateChannelReqData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateChannelReqData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChannelReqData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateClientReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateClientReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCreateClientReq = [1]string{
	0: "data",
}

// Decode decodes CreateClientReq from json.
func (s *CreateClientReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateClientReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateClientReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateClientReq) {
					name = jsonFieldsNameOfCreateClientReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateClientReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateClientReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateClientReqData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateClientReqData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("clientID")
		s.ClientID.Encode(e)
	}
	{
		e.FieldStart("clientUsername")
		e.Str(s.ClientUsername)
	}
	{
		e.FieldStart("activeBalance")
		e.Float64(s.ActiveBalance)
	}
	{
		e.FieldStart("blockedBalance")
		e.Float64(s.BlockedBalance)
	}
	{
		e.FieldStart("profitBalance")
		e.Float64(s.ProfitBalance)
	}
	{
		e.FieldStart("withdrawlBalance")
		e.Float64(s.WithdrawlBalance)
	}
	{
		if s.OrganisationID.Set {
			e.FieldStart("organisationID")
			s.OrganisationID.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateClientReqData = [7]string{
	0: "clientID",
	1: "clientUsername",
	2: "activeBalance",
	3: "blockedBalance",
	4: "profitBalance",
	5: "withdrawlBalance",
	6: "organisationID",
}

// Decode decodes CreateClientReqData from json.
func (s *CreateClientReqData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateClientReqData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientID\"")
			}
		case "clientUsername":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ClientUsername = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientUsername\"")
			}
		case "activeBalance":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.ActiveBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeBalance\"")
			}
		case "blockedBalance":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.BlockedBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockedBalance\"")
			}
		case "profitBalance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.ProfitBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profitBalance\"")
			}
		case "withdrawlBalance":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.WithdrawlBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withdrawlBalance\"")
			}
		case "organisationID":
			if err := func() error {
				s.OrganisationID.Reset()
				if err := s.OrganisationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organisationID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateClientReqData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateClientReqData) {
					name = jsonFieldsNameOfCreateClientReqData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateClientReqData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateClientReqData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateOrganisationReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateOrganisationReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCreateOrganisationReq = [1]string{
	0: "data",
}

// Decode decodes CreateOrganisationReq from json.
func (s *CreateOrganisationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateOrganisationReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateOrganisationReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateOrganisationReq) {
					name = jsonFieldsNameOfCreateOrganisationReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateOrganisationReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateOrganisationReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DiscountID as json.
func (s DiscountID) Encode(e *jx.Encoder) {
	unwrapped := int(s)

	e.Int(unwrapped)
}

// Decode decodes DiscountID from json.
func (s *DiscountID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DiscountID to nil")
	}
	var unwrapped int
	if err := func() error {
		v, err := d.Int()
		unwrapped = int(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DiscountID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DiscountID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DiscountID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("error")
		s.Error.Encode(e)
	}
}

var jsonFieldsNameOfError = [1]string{
	0: "error",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Int(s.Status)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrorError = [4]string{
	0: "status",
	1: "name",
	2: "message",
	3: "details",
}

// Decode decodes ErrorError from json.
func (s *ErrorError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Status = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrorError) {
					name = jsonFieldsNameOfErrorError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorErrorDetails) encodeFields(e *jx.Encoder) {
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfErrorErrorDetails = [1]string{
	0: "errors",
}

// Decode decodes ErrorErrorDetails from json.
func (s *ErrorErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorErrorDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "errors":
			if err := func() error {
				s.Errors = make([]ErrorErrorDetailsErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ErrorErrorDetailsErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorErrorDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorErrorDetailsErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorErrorDetailsErrorsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Path != nil {
			e.FieldStart("path")
			e.ArrStart()
			for _, elem := range s.Path {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrorErrorDetailsErrorsItem = [3]string{
	0: "path",
	1: "message",
	2: "name",
}

// Decode decodes ErrorErrorDetailsErrorsItem from json.
func (s *ErrorErrorDetailsErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorErrorDetailsErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			if err := func() error {
				s.Path = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Path = append(s.Path, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorErrorDetailsErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorErrorDetailsErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorErrorDetailsErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetChannelsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetChannelsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetChannelsResponse = [1]string{
	0: "data",
}

// Decode decodes GetChannelsResponse from json.
func (s *GetChannelsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetChannelsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]GetChannelsResponseDataItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetChannelsResponseDataItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetChannelsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetChannelsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetChannelsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetChannelsResponseDataItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetChannelsResponseDataItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
}

var jsonFieldsNameOfGetChannelsResponseDataItem = [2]string{
	0: "id",
	1: "attributes",
}

// Decode decodes GetChannelsResponseDataItem from json.
func (s *GetChannelsResponseDataItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetChannelsResponseDataItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetChannelsResponseDataItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetChannelsResponseDataItem) {
					name = jsonFieldsNameOfGetChannelsResponseDataItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetChannelsResponseDataItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetChannelsResponseDataItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClientBadRequest as json.
func (s *GetClientBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClientBadRequest from json.
func (s *GetClientBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClientBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClientBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClientBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClientBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClientByFilterBadRequest as json.
func (s *GetClientByFilterBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClientByFilterBadRequest from json.
func (s *GetClientByFilterBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClientByFilterBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClientByFilterBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClientByFilterBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClientByFilterBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClientByFilterNotFound as json.
func (s *GetClientByFilterNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClientByFilterNotFound from json.
func (s *GetClientByFilterNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClientByFilterNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClientByFilterNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClientByFilterNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClientByFilterNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetClientNotFound as json.
func (s *GetClientNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetClientNotFound from json.
func (s *GetClientNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetClientNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetClientNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetClientNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetClientNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCommissionsBadRequest as json.
func (s *GetCommissionsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCommissionsBadRequest from json.
func (s *GetCommissionsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCommissionsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCommissionsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCommissionsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCommissionsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCommissionsNotFound as json.
func (s *GetCommissionsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCommissionsNotFound from json.
func (s *GetCommissionsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCommissionsNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCommissionsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCommissionsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCommissionsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetCommissionsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetCommissionsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetCommissionsResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes GetCommissionsResponse from json.
func (s *GetCommissionsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCommissionsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]GetCommissionsResponseDataItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetCommissionsResponseDataItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetCommissionsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCommissionsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCommissionsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetCommissionsResponseDataItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetCommissionsResponseDataItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Attributes.Set {
			e.FieldStart("attributes")
			s.Attributes.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetCommissionsResponseDataItem = [2]string{
	0: "id",
	1: "attributes",
}

// Decode decodes GetCommissionsResponseDataItem from json.
func (s *GetCommissionsResponseDataItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCommissionsResponseDataItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			if err := func() error {
				s.Attributes.Reset()
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetCommissionsResponseDataItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCommissionsResponseDataItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCommissionsResponseDataItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetCommissionsResponseMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetCommissionsResponseMeta) encodeFields(e *jx.Encoder) {
	{
		if s.Pagination.Set {
			e.FieldStart("pagination")
			s.Pagination.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetCommissionsResponseMeta = [1]string{
	0: "pagination",
}

// Decode decodes GetCommissionsResponseMeta from json.
func (s *GetCommissionsResponseMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCommissionsResponseMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pagination":
			if err := func() error {
				s.Pagination.Reset()
				if err := s.Pagination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pagination\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetCommissionsResponseMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCommissionsResponseMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCommissionsResponseMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDiscountsBadRequest as json.
func (s *GetDiscountsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDiscountsBadRequest from json.
func (s *GetDiscountsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDiscountsBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDiscountsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDiscountsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDiscountsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDiscountsNotFound as json.
func (s *GetDiscountsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDiscountsNotFound from json.
func (s *GetDiscountsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDiscountsNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDiscountsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDiscountsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDiscountsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDiscountsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDiscountsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetDiscountsResponse = [1]string{
	0: "data",
}

// Decode decodes GetDiscountsResponse from json.
func (s *GetDiscountsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDiscountsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]GetDiscountsResponseDataItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetDiscountsResponseDataItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDiscountsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDiscountsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDiscountsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDiscountsResponseDataItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDiscountsResponseDataItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Attributes.Set {
			e.FieldStart("attributes")
			s.Attributes.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDiscountsResponseDataItem = [2]string{
	0: "id",
	1: "attributes",
}

// Decode decodes GetDiscountsResponseDataItem from json.
func (s *GetDiscountsResponseDataItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDiscountsResponseDataItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			if err := func() error {
				s.Attributes.Reset()
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDiscountsResponseDataItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDiscountsResponseDataItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDiscountsResponseDataItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOrganisationBadRequest as json.
func (s *GetOrganisationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetOrganisationBadRequest from json.
func (s *GetOrganisationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOrganisationBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetOrganisationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOrganisationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOrganisationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOrganisationNotFound as json.
func (s *GetOrganisationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetOrganisationNotFound from json.
func (s *GetOrganisationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOrganisationNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetOrganisationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOrganisationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOrganisationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Multiplier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Multiplier) encodeFields(e *jx.Encoder) {
	{
		if s.UserID.Set {
			e.FieldStart("user_Id")
			s.UserID.Encode(e)
		}
	}
	{
		if s.ClientMultiplier.Set {
			e.FieldStart("client_multiplier")
			s.ClientMultiplier.Encode(e)
		}
	}
	{
		if s.AdminMultiplier.Set {
			e.FieldStart("admin_multiplier")
			s.AdminMultiplier.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PublishedAt.Set {
			e.FieldStart("publishedAt")
			s.PublishedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfMultiplier = [6]string{
	0: "user_Id",
	1: "client_multiplier",
	2: "admin_multiplier",
	3: "createdAt",
	4: "updatedAt",
	5: "publishedAt",
}

// Decode decodes Multiplier from json.
func (s *Multiplier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Multiplier to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_Id":
			if err := func() error {
				s.UserID.Reset()
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_Id\"")
			}
		case "client_multiplier":
			if err := func() error {
				s.ClientMultiplier.Reset()
				if err := s.ClientMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_multiplier\"")
			}
		case "admin_multiplier":
			if err := func() error {
				s.AdminMultiplier.Reset()
				if err := s.AdminMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin_multiplier\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "publishedAt":
			if err := func() error {
				s.PublishedAt.Reset()
				if err := s.PublishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publishedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Multiplier")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Multiplier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Multiplier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClientByFilterResponseMeta as json.
func (o OptClientByFilterResponseMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ClientByFilterResponseMeta from json.
func (o *OptClientByFilterResponseMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClientByFilterResponseMeta to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClientByFilterResponseMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClientByFilterResponseMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClientCrmID as json.
func (o OptClientCrmID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ClientCrmID from json.
func (o *OptClientCrmID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClientCrmID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClientCrmID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClientCrmID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClientDataAttributes as json.
func (o OptClientDataAttributes) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ClientDataAttributes from json.
func (o *OptClientDataAttributes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClientDataAttributes to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClientDataAttributes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClientDataAttributes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClientResponseData as json.
func (o OptClientResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ClientResponseData from json.
func (o *OptClientResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClientResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClientResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClientResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClientResponseDataAttributes as json.
func (o OptClientResponseDataAttributes) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ClientResponseDataAttributes from json.
func (o *OptClientResponseDataAttributes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClientResponseDataAttributes to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClientResponseDataAttributes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClientResponseDataAttributes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CommissionID as json.
func (o OptCommissionID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CommissionID from json.
func (o *OptCommissionID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCommissionID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCommissionID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCommissionID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDate) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDate) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDate to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDate)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDate)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DiscountID as json.
func (o OptDiscountID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DiscountID from json.
func (o *OptDiscountID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDiscountID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDiscountID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDiscountID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorErrorDetails as json.
func (o OptErrorErrorDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ErrorErrorDetails from json.
func (o *OptErrorErrorDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptErrorErrorDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptErrorErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptErrorErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCommissionsResponseMeta as json.
func (o OptGetCommissionsResponseMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetCommissionsResponseMeta from json.
func (o *OptGetCommissionsResponseMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetCommissionsResponseMeta to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetCommissionsResponseMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetCommissionsResponseMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Multiplier as json.
func (o OptMultiplier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Multiplier from json.
func (o *OptMultiplier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMultiplier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMultiplier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMultiplier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptNilDate) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptNilDate) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilDate to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDate)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDate)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrganisationCrmID as json.
func (o OptOrganisationCrmID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrganisationCrmID from json.
func (o *OptOrganisationCrmID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrganisationCrmID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrganisationCrmID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrganisationCrmID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrganisationID as json.
func (o OptOrganisationID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrganisationID from json.
func (o *OptOrganisationID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrganisationID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrganisationID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrganisationID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrganisationType as json.
func (o OptOrganisationType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes OrganisationType from json.
func (o *OptOrganisationType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrganisationType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrganisationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrganisationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrganisationWithDateInfo as json.
func (o OptOrganisationWithDateInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OrganisationWithDateInfo from json.
func (o *OptOrganisationWithDateInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrganisationWithDateInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrganisationWithDateInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrganisationWithDateInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Pagination as json.
func (o OptPagination) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Pagination from json.
func (o *OptPagination) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPagination to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPagination) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPagination) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserID as json.
func (o OptUserID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserID from json.
func (o *OptUserID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WrappedOrganisationResponse as json.
func (o OptWrappedOrganisationResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WrappedOrganisationResponse from json.
func (o *OptWrappedOrganisationResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWrappedOrganisationResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWrappedOrganisationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWrappedOrganisationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WrappedOrganisationResponseData as json.
func (o OptWrappedOrganisationResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WrappedOrganisationResponseData from json.
func (o *OptWrappedOrganisationResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWrappedOrganisationResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWrappedOrganisationResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWrappedOrganisationResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Organisation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Organisation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("organisationID")
		s.OrganisationID.Encode(e)
	}
	{
		e.FieldStart("fullName")
		e.Str(s.FullName)
	}
	{
		e.FieldStart("organisationName")
		e.Str(s.OrganisationName)
	}
	{
		e.FieldStart("organisationType")
		s.OrganisationType.Encode(e)
	}
	{
		e.FieldStart("inn")
		e.Str(s.Inn)
	}
	{
		e.FieldStart("ogrn")
		e.Str(s.Ogrn)
	}
	{
		e.FieldStart("kpp")
		e.Str(s.Kpp)
	}
	{
		e.FieldStart("internalContractAdmin")
		e.Str(s.InternalContractAdmin)
	}
	{
		e.FieldStart("internalContractAdvertiser")
		e.Str(s.InternalContractAdvertiser)
	}
	{
		e.FieldStart("ordContractAdmin")
		e.Str(s.OrdContractAdmin)
	}
	{
		e.FieldStart("ordContractAdvertiser")
		e.Str(s.OrdContractAdvertiser)
	}
	{
		e.FieldStart("activeBalance")
		e.Float64(s.ActiveBalance)
	}
	{
		e.FieldStart("blockedBalance")
		e.Float64(s.BlockedBalance)
	}
	{
		e.FieldStart("profitBalance")
		e.Float64(s.ProfitBalance)
	}
	{
		e.FieldStart("withdrawlBalance")
		e.Float64(s.WithdrawlBalance)
	}
	{
		if s.BirthDate.Set {
			e.FieldStart("birthDate")
			s.BirthDate.Encode(e, json.EncodeDate)
		}
	}
}

var jsonFieldsNameOfOrganisation = [16]string{
	0:  "organisationID",
	1:  "fullName",
	2:  "organisationName",
	3:  "organisationType",
	4:  "inn",
	5:  "ogrn",
	6:  "kpp",
	7:  "internalContractAdmin",
	8:  "internalContractAdvertiser",
	9:  "ordContractAdmin",
	10: "ordContractAdvertiser",
	11: "activeBalance",
	12: "blockedBalance",
	13: "profitBalance",
	14: "withdrawlBalance",
	15: "birthDate",
}

// Decode decodes Organisation from json.
func (s *Organisation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Organisation to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "organisationID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.OrganisationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organisationID\"")
			}
		case "fullName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fullName\"")
			}
		case "organisationName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.OrganisationName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organisationName\"")
			}
		case "organisationType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.OrganisationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organisationType\"")
			}
		case "inn":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Inn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inn\"")
			}
		case "ogrn":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Ogrn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ogrn\"")
			}
		case "kpp":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Kpp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kpp\"")
			}
		case "internalContractAdmin":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InternalContractAdmin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internalContractAdmin\"")
			}
		case "internalContractAdvertiser":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.InternalContractAdvertiser = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internalContractAdvertiser\"")
			}
		case "ordContractAdmin":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.OrdContractAdmin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ordContractAdmin\"")
			}
		case "ordContractAdvertiser":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.OrdContractAdvertiser = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ordContractAdvertiser\"")
			}
		case "activeBalance":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.ActiveBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeBalance\"")
			}
		case "blockedBalance":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.BlockedBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockedBalance\"")
			}
		case "profitBalance":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.ProfitBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profitBalance\"")
			}
		case "withdrawlBalance":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.WithdrawlBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withdrawlBalance\"")
			}
		case "birthDate":
			if err := func() error {
				s.BirthDate.Reset()
				if err := s.BirthDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthDate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Organisation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrganisation) {
					name = jsonFieldsNameOfOrganisation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Organisation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Organisation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrganisationCrmID as json.
func (s OrganisationCrmID) Encode(e *jx.Encoder) {
	unwrapped := int(s)

	e.Int(unwrapped)
}

// Decode decodes OrganisationCrmID from json.
func (s *OrganisationCrmID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganisationCrmID to nil")
	}
	var unwrapped int
	if err := func() error {
		v, err := d.Int()
		unwrapped = int(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrganisationCrmID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrganisationCrmID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrganisationCrmID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrganisationID as json.
func (s OrganisationID) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes OrganisationID from json.
func (s *OrganisationID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganisationID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrganisationID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrganisationID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrganisationID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrganisationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrganisationResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
}

var jsonFieldsNameOfOrganisationResponse = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes OrganisationResponse from json.
func (s *OrganisationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganisationResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrganisationResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrganisationResponse) {
					name = jsonFieldsNameOfOrganisationResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrganisationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrganisationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrganisationResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrganisationResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Attributes.Set {
			e.FieldStart("attributes")
			s.Attributes.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrganisationResponseData = [2]string{
	0: "id",
	1: "attributes",
}

// Decode decodes OrganisationResponseData from json.
func (s *OrganisationResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganisationResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			if err := func() error {
				s.Attributes.Reset()
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrganisationResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrganisationResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrganisationResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrganisationResponseMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrganisationResponseMeta) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfOrganisationResponseMeta = [0]string{}

// Decode decodes OrganisationResponseMeta from json.
func (s *OrganisationResponseMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganisationResponseMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return errors.Errorf("unexpected field %q", k)
		}
	}); err != nil {
		return errors.Wrap(err, "decode OrganisationResponseMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrganisationResponseMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrganisationResponseMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrganisationType as json.
func (s OrganisationType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrganisationType from json.
func (s *OrganisationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganisationType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrganisationType(v) {
	case OrganisationType_0:
		*s = OrganisationType_0
	case OrganisationType_1:
		*s = OrganisationType_1
	case OrganisationType_2:
		*s = OrganisationType_2
	default:
		*s = OrganisationType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrganisationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrganisationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrganisationWithDateInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrganisationWithDateInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("organisationID")
		s.OrganisationID.Encode(e)
	}
	{
		e.FieldStart("fullName")
		e.Str(s.FullName)
	}
	{
		e.FieldStart("organisationName")
		e.Str(s.OrganisationName)
	}
	{
		e.FieldStart("organisationType")
		s.OrganisationType.Encode(e)
	}
	{
		e.FieldStart("inn")
		e.Str(s.Inn)
	}
	{
		e.FieldStart("ogrn")
		e.Str(s.Ogrn)
	}
	{
		e.FieldStart("kpp")
		e.Str(s.Kpp)
	}
	{
		e.FieldStart("internalContractAdmin")
		e.Str(s.InternalContractAdmin)
	}
	{
		e.FieldStart("internalContractAdvertiser")
		e.Str(s.InternalContractAdvertiser)
	}
	{
		e.FieldStart("ordContractAdmin")
		e.Str(s.OrdContractAdmin)
	}
	{
		e.FieldStart("ordContractAdvertiser")
		e.Str(s.OrdContractAdvertiser)
	}
	{
		e.FieldStart("activeBalance")
		e.Float64(s.ActiveBalance)
	}
	{
		e.FieldStart("blockedBalance")
		e.Float64(s.BlockedBalance)
	}
	{
		e.FieldStart("profitBalance")
		e.Float64(s.ProfitBalance)
	}
	{
		e.FieldStart("withdrawlBalance")
		e.Float64(s.WithdrawlBalance)
	}
	{
		if s.BirthDate.Set {
			e.FieldStart("birthDate")
			s.BirthDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PublishedAt.Set {
			e.FieldStart("publishedAt")
			s.PublishedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfOrganisationWithDateInfo = [19]string{
	0:  "organisationID",
	1:  "fullName",
	2:  "organisationName",
	3:  "organisationType",
	4:  "inn",
	5:  "ogrn",
	6:  "kpp",
	7:  "internalContractAdmin",
	8:  "internalContractAdvertiser",
	9:  "ordContractAdmin",
	10: "ordContractAdvertiser",
	11: "activeBalance",
	12: "blockedBalance",
	13: "profitBalance",
	14: "withdrawlBalance",
	15: "birthDate",
	16: "createdAt",
	17: "updatedAt",
	18: "publishedAt",
}

// Decode decodes OrganisationWithDateInfo from json.
func (s *OrganisationWithDateInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrganisationWithDateInfo to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "organisationID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.OrganisationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organisationID\"")
			}
		case "fullName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FullName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fullName\"")
			}
		case "organisationName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.OrganisationName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organisationName\"")
			}
		case "organisationType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.OrganisationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organisationType\"")
			}
		case "inn":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Inn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inn\"")
			}
		case "ogrn":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Ogrn = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ogrn\"")
			}
		case "kpp":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Kpp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kpp\"")
			}
		case "internalContractAdmin":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.InternalContractAdmin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internalContractAdmin\"")
			}
		case "internalContractAdvertiser":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.InternalContractAdvertiser = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internalContractAdvertiser\"")
			}
		case "ordContractAdmin":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.OrdContractAdmin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ordContractAdmin\"")
			}
		case "ordContractAdvertiser":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.OrdContractAdvertiser = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ordContractAdvertiser\"")
			}
		case "activeBalance":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.ActiveBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeBalance\"")
			}
		case "blockedBalance":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.BlockedBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockedBalance\"")
			}
		case "profitBalance":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.ProfitBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profitBalance\"")
			}
		case "withdrawlBalance":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.WithdrawlBalance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withdrawlBalance\"")
			}
		case "birthDate":
			if err := func() error {
				s.BirthDate.Reset()
				if err := s.BirthDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthDate\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "publishedAt":
			if err := func() error {
				s.PublishedAt.Reset()
				if err := s.PublishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publishedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrganisationWithDateInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b01111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrganisationWithDateInfo) {
					name = jsonFieldsNameOfOrganisationWithDateInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrganisationWithDateInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrganisationWithDateInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Pagination) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Pagination) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("page")
		e.Int(s.Page)
	}
	{
		e.FieldStart("pageSize")
		e.Int(s.PageSize)
	}
	{
		e.FieldStart("pageCount")
		e.Int(s.PageCount)
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
}

var jsonFieldsNameOfPagination = [4]string{
	0: "page",
	1: "pageSize",
	2: "pageCount",
	3: "total",
}

// Decode decodes Pagination from json.
func (s *Pagination) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Pagination to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Page = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "pageSize":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.PageSize = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageSize\"")
			}
		case "pageCount":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.PageCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageCount\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Pagination")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPagination) {
					name = jsonFieldsNameOfPagination[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Pagination) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Pagination) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PartialOrganization) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PartialOrganization) encodeFields(e *jx.Encoder) {
	{
		if s.OrganisationID.Set {
			e.FieldStart("organisationID")
			s.OrganisationID.Encode(e)
		}
	}
	{
		if s.FullName.Set {
			e.FieldStart("fullName")
			s.FullName.Encode(e)
		}
	}
	{
		if s.OrganisationType.Set {
			e.FieldStart("organisationType")
			s.OrganisationType.Encode(e)
		}
	}
	{
		if s.Inn.Set {
			e.FieldStart("inn")
			s.Inn.Encode(e)
		}
	}
	{
		if s.Orgn.Set {
			e.FieldStart("orgn")
			s.Orgn.Encode(e)
		}
	}
	{
		if s.Kpp.Set {
			e.FieldStart("kpp")
			s.Kpp.Encode(e)
		}
	}
	{
		if s.InternalContractAdmin.Set {
			e.FieldStart("internalContractAdmin")
			s.InternalContractAdmin.Encode(e)
		}
	}
	{
		if s.InternalContractAdvertiser.Set {
			e.FieldStart("internalContractAdvertiser")
			s.InternalContractAdvertiser.Encode(e)
		}
	}
	{
		if s.OrdContractAdmin.Set {
			e.FieldStart("ordContractAdmin")
			s.OrdContractAdmin.Encode(e)
		}
	}
	{
		if s.OrdContractAdvertiser.Set {
			e.FieldStart("ordContractAdvertiser")
			s.OrdContractAdvertiser.Encode(e)
		}
	}
	{
		if s.ActiveBalance.Set {
			e.FieldStart("activeBalance")
			s.ActiveBalance.Encode(e)
		}
	}
	{
		if s.BlockedBalance.Set {
			e.FieldStart("blockedBalance")
			s.BlockedBalance.Encode(e)
		}
	}
	{
		if s.ProfitBalance.Set {
			e.FieldStart("profitBalance")
			s.ProfitBalance.Encode(e)
		}
	}
	{
		if s.WithdrawlBalance.Set {
			e.FieldStart("withdrawlBalance")
			s.WithdrawlBalance.Encode(e)
		}
	}
	{
		if s.BirthDate.Set {
			e.FieldStart("birthDate")
			s.BirthDate.Encode(e, json.EncodeDate)
		}
	}
}

var jsonFieldsNameOfPartialOrganization = [15]string{
	0:  "organisationID",
	1:  "fullName",
	2:  "organisationType",
	3:  "inn",
	4:  "orgn",
	5:  "kpp",
	6:  "internalContractAdmin",
	7:  "internalContractAdvertiser",
	8:  "ordContractAdmin",
	9:  "ordContractAdvertiser",
	10: "activeBalance",
	11: "blockedBalance",
	12: "profitBalance",
	13: "withdrawlBalance",
	14: "birthDate",
}

// Decode decodes PartialOrganization from json.
func (s *PartialOrganization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PartialOrganization to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "organisationID":
			if err := func() error {
				s.OrganisationID.Reset()
				if err := s.OrganisationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organisationID\"")
			}
		case "fullName":
			if err := func() error {
				s.FullName.Reset()
				if err := s.FullName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fullName\"")
			}
		case "organisationType":
			if err := func() error {
				s.OrganisationType.Reset()
				if err := s.OrganisationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organisationType\"")
			}
		case "inn":
			if err := func() error {
				s.Inn.Reset()
				if err := s.Inn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inn\"")
			}
		case "orgn":
			if err := func() error {
				s.Orgn.Reset()
				if err := s.Orgn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orgn\"")
			}
		case "kpp":
			if err := func() error {
				s.Kpp.Reset()
				if err := s.Kpp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kpp\"")
			}
		case "internalContractAdmin":
			if err := func() error {
				s.InternalContractAdmin.Reset()
				if err := s.InternalContractAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internalContractAdmin\"")
			}
		case "internalContractAdvertiser":
			if err := func() error {
				s.InternalContractAdvertiser.Reset()
				if err := s.InternalContractAdvertiser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internalContractAdvertiser\"")
			}
		case "ordContractAdmin":
			if err := func() error {
				s.OrdContractAdmin.Reset()
				if err := s.OrdContractAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ordContractAdmin\"")
			}
		case "ordContractAdvertiser":
			if err := func() error {
				s.OrdContractAdvertiser.Reset()
				if err := s.OrdContractAdvertiser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ordContractAdvertiser\"")
			}
		case "activeBalance":
			if err := func() error {
				s.ActiveBalance.Reset()
				if err := s.ActiveBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeBalance\"")
			}
		case "blockedBalance":
			if err := func() error {
				s.BlockedBalance.Reset()
				if err := s.BlockedBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockedBalance\"")
			}
		case "profitBalance":
			if err := func() error {
				s.ProfitBalance.Reset()
				if err := s.ProfitBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profitBalance\"")
			}
		case "withdrawlBalance":
			if err := func() error {
				s.WithdrawlBalance.Reset()
				if err := s.WithdrawlBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withdrawlBalance\"")
			}
		case "birthDate":
			if err := func() error {
				s.BirthDate.Reset()
				if err := s.BirthDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthDate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PartialOrganization")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PartialOrganization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PartialOrganization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateClientBadRequest as json.
func (s *UpdateClientBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateClientBadRequest from json.
func (s *UpdateClientBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateClientBadRequest to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateClientBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateClientBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateClientBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateClientNotFound as json.
func (s *UpdateClientNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*Error)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateClientNotFound from json.
func (s *UpdateClientNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateClientNotFound to nil")
	}
	var unwrapped Error
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateClientNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateClientNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateClientNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateClientReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateClientReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfUpdateClientReq = [1]string{
	0: "data",
}

// Decode decodes UpdateClientReq from json.
func (s *UpdateClientReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateClientReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateClientReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateClientReq) {
					name = jsonFieldsNameOfUpdateClientReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateClientReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateClientReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateClientReqData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateClientReqData) encodeFields(e *jx.Encoder) {
	{
		if s.ClientID.Set {
			e.FieldStart("clientID")
			s.ClientID.Encode(e)
		}
	}
	{
		if s.ClientUsername.Set {
			e.FieldStart("clientUsername")
			s.ClientUsername.Encode(e)
		}
	}
	{
		if s.ActiveBalance.Set {
			e.FieldStart("activeBalance")
			s.ActiveBalance.Encode(e)
		}
	}
	{
		if s.ProfitBalance.Set {
			e.FieldStart("profitBalance")
			s.ProfitBalance.Encode(e)
		}
	}
	{
		if s.BlockedBalance.Set {
			e.FieldStart("blockedBalance")
			s.BlockedBalance.Encode(e)
		}
	}
	{
		if s.WithdrawlBalance.Set {
			e.FieldStart("withdrawlBalance")
			s.WithdrawlBalance.Encode(e)
		}
	}
	{
		if s.OrganisationID.Set {
			e.FieldStart("organisationID")
			s.OrganisationID.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateClientReqData = [7]string{
	0: "clientID",
	1: "clientUsername",
	2: "activeBalance",
	3: "profitBalance",
	4: "blockedBalance",
	5: "withdrawlBalance",
	6: "organisationID",
}

// Decode decodes UpdateClientReqData from json.
func (s *UpdateClientReqData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateClientReqData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientID":
			if err := func() error {
				s.ClientID.Reset()
				if err := s.ClientID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientID\"")
			}
		case "clientUsername":
			if err := func() error {
				s.ClientUsername.Reset()
				if err := s.ClientUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientUsername\"")
			}
		case "activeBalance":
			if err := func() error {
				s.ActiveBalance.Reset()
				if err := s.ActiveBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeBalance\"")
			}
		case "profitBalance":
			if err := func() error {
				s.ProfitBalance.Reset()
				if err := s.ProfitBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profitBalance\"")
			}
		case "blockedBalance":
			if err := func() error {
				s.BlockedBalance.Reset()
				if err := s.BlockedBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockedBalance\"")
			}
		case "withdrawlBalance":
			if err := func() error {
				s.WithdrawlBalance.Reset()
				if err := s.WithdrawlBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withdrawlBalance\"")
			}
		case "organisationID":
			if err := func() error {
				s.OrganisationID.Reset()
				if err := s.OrganisationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organisationID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateClientReqData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateClientReqData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateClientReqData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateOrganisationReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateOrganisationReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfUpdateOrganisationReq = [1]string{
	0: "data",
}

// Decode decodes UpdateOrganisationReq from json.
func (s *UpdateOrganisationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateOrganisationReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateOrganisationReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateOrganisationReq) {
					name = jsonFieldsNameOfUpdateOrganisationReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateOrganisationReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateOrganisationReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserID as json.
func (s UserID) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes UserID from json.
func (s *UserID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UserID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WrappedOrganisationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WrappedOrganisationResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfWrappedOrganisationResponse = [1]string{
	0: "data",
}

// Decode decodes WrappedOrganisationResponse from json.
func (s *WrappedOrganisationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WrappedOrganisationResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WrappedOrganisationResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WrappedOrganisationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WrappedOrganisationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WrappedOrganisationResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WrappedOrganisationResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Attributes.Set {
			e.FieldStart("attributes")
			s.Attributes.Encode(e)
		}
	}
}

var jsonFieldsNameOfWrappedOrganisationResponseData = [2]string{
	0: "id",
	1: "attributes",
}

// Decode decodes WrappedOrganisationResponseData from json.
func (s *WrappedOrganisationResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WrappedOrganisationResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			if err := func() error {
				s.Attributes.Reset()
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WrappedOrganisationResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WrappedOrganisationResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WrappedOrganisationResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
